# artomator (Artifact Registry Automator, naming is hard)


[![Go Report Card](https://goreportcard.com/badge/github.com/mchmarny/artomator)](https://goreportcard.com/report/github.com/mchmarny/artomator) ![GitHub go.mod Go version](https://img.shields.io/github/go-mod/go-version/mchmarny/artomator) [![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://github.com/gojp/goreportcard/blob/master/LICENSE)

Automates the creation of [Software Bill of Materials (SBOM)](https://www.cisa.gov/sbom), and vulnerability scanning of container images. When deployed in your GCP project, `artomator` will automatically process any image that is pushed into [Artifact Registry (AR)](https://cloud.google.com/artifact-registry) with one of the expected [label](https://docs.docker.com/config/labels-custom-metadata/). For example:

```shell
docker build -t $TAG --label artomator-sbom=spdx .
```

The `artomator-sbom=spdx` label in the above `docker build` commend will tell `artomator` to add SBOM attestations in an [SPDX](https://spdx.dev/) format (the supported formats are: `cyclonedx` or `spdx`).

![](images/flow.png)

> `artomator` also exposes an attestation verification and runtime vulnerability discovery APIs. See API section for details

## how it works

1. Whenever an image is published to the Artifact Registry 
2. A [registry event](https://cloud.google.com/artifact-registry/docs/configure-notifications) is automatically published if there is a [PubSub](https://cloud.google.com/pubsub/docs/overview) topic named `gcr` in the same project
3. PubSub subscription pushes that event to `artomator` service in [Cloud Run](https://cloud.google.com/run) with the operation type (e.g. `INSERT`) and the image digest
4. The `artomator` service retrieves metadata for that image from the registry and check its labels
5. If the image includes `artomator-sbom` label, the service signs that image using KMS key
6. A new attestation (type `spdx`) is being added to the image in the registry
7. (optional) If GCS bucket is configured, `artomator` will also persist the generated artifacts
8. Binary Authorization attestation is then created using the `artomator-attestor` (for optional BinAuthZ policy)
9. Stores the processed image digests in a Redis store to avoid re-processing the same image (technically adding attestation to an image creates yet another event, so this could cause recursion without that check)

To processes images, `artomator` uses:

* [cosign](https://github.com/sigstore/cosign) for image signing and verification
* [syft](https://github.com/anchore/syft) for SBOM generation 
* [trivy](https://github.com/aquasecurity/trivy) for vulnerability scans 
* [jq](https://stedolan.github.io/jq/) for JSON operations 

## artifacts 

> For examples of attestations generated by `artomator` see the SBOM ([sbom.json](sbom.json)) and vulnerability report ([vuln.json](vuln.json)) on the `artomator` itself.

In addition to attaching these to image as attestations, `artomator` also saves all the generated files in GCS. To make these names predictable, `artomator` prefixes them with the SHA from the image digest. For example, if the image digest was:

```shell
us-west1-docker.pkg.dev/cloudy-demos/artomator/tester@sha256:acaccb6c8f975ee7df7f46468fae28fb5014cf02c2835d2dc37bf6961e648838
```

then the list of artifacts in the registry for that image will be: 

* acaccb6c8f975ee7df7f46468fae28fb5014cf02c2835d2dc37bf6961e648838-sbom.json
* acaccb6c8f975ee7df7f46468fae28fb5014cf02c2835d2dc37bf6961e648838-vuln.json
* acaccb6c8f975ee7df7f46468fae28fb5014cf02c2835d2dc37bf6961e648838-meta.json

where:

* `-sbom.json` is SPDX 2.3 formatted SBOM file
* `-vuln.json` is the vulnerability report based on the SBOM based on `trivy` DB
* `-meta.json` is the image metadata in the registry as it was when the image was processed

## api 

`artomator` exposes also APIs for image attestation verification and runtime vulnerability discovery. 

### image attestation verification api

The `artomator` service exposes (GET `/verify`) API which you can query with the image digest to verify the expected attestations on the image.

> Note, access to the `artomator` service requires `roles/run.invoker` IAM role

First, start by exporting the `artomator` service URL:

```shell
export SERVICE_URL=$(gcloud run services describe artomator \
  --region $REGION --format="value(status.url)")
```

Then, to query the verify endpoint:

```shell
curl -i -H "Authorization: Bearer $(gcloud auth print-identity-token)" \
     -H "Content-Type: application/json" \
     -H "X-Goog-User-Project: ${PROJECT_ID}" \
     "${SERVICE_URL}/verify?type=spdx&digest=${IMAGE_DIGEST}"
```

If the required attestation for SPDX formatted SBOM (`https://spdx.dev/Document`) is found, `artomator` will return the entire attestation.

## verify processed image using cosign

To verify the attestation for `artomator` processed images you will need the KMS key name that was used to sign that image. You retrieve it using the following command:

```shell
export SIGN_KEY=$(gcloud kms keys describe artomator-signer \
  --project $PROJECT_ID \
  --location $REGION \
  --keyring artomator \
  --format json | jq --raw-output '.name')
```

You can check the key like this: 

```shell
echo $SIGN_KEY
```

It should look something like this

```shell
projects/$PROJECT_ID/locations/$REGION/keyRings/artomator/cryptoKeys/artomator-signer/cryptoKeyVersions/1
```

Once have the signing key, you can verify any image that was processed by `artomator` like this:

> Note, the `$IMAGE_DIGEST` has to be the fully qualified image URI with the SHA. For example `us-west1-docker.pkg.dev/cloudy-demos/artomator/tester@sha256:59d5b8eb5525307dde52aa51382676e74240bb79eb92a67a1f2a760382a21d78`

```shell
cosign verify-attestation --type=spdx --key "gcpkms://${SIGN_KEY}" $IMAGE_DIGEST \
    | jq -r .payload | base64 -d | jq -r .predicateType
```

> Note, you can check the attestation for either of the two types that `artomator` creates by changing the `--type` flag in the above command to either `spdx` (SBOM), `vuln` which is the vulnerability report

The result should look something like this: 

```shell
Verification for us-west1-docker.pkg.dev/cloudy-demos/artomator/tester@sha256:59d5b8eb5525307dde52aa51382676e74240bb79eb92a67a1f2a760382a21d78 --
The following checks were performed on each of these signatures:
  - The cosign claims were validated
  - The signatures were verified against the specified public key
https://spdx.dev/Document
```

To save any of these artifacts locally: 

```shell
cosign verify-attestation --type=spdx --key "gcpkms://${SIGN_KEY}" $IMAGE_DIGEST \
    | jq -r .payload | base64 -d > sbom.spdx.json
```

## deployment 

The prerequisites to deploy `artomator` include: 

* [Terraform CLI](https://www.terraform.io/downloads)
* [GCP Project](https://cloud.google.com/resource-manager/docs/creating-managing-projects)
* [gcloud CLI](https://cloud.google.com/sdk/gcloud)
  
> Good how-to on using terraform with GCP is located [here](https://cloud.google.com/community/tutorials/getting-started-on-gcp-with-terraform).

To deploy the prebuilt `artomator`, first clone this repo:

```shell
git clone git@github.com:mchmarny/artomator.git
```

Once you've cloned the setup repo, navigate inside of that cloned directory and initialize Terraform

> Make sure to authenticate to GCP using `gcloud auth application-default login` if you haven't done it already.

```shell
cd deployment

terraform init
```

> Note, this flow uses the default, local terraform state. Make sure you do not check the state files into your source control (see `.gitignore`), or consider using persistent state provider like GCS.


When done, apply the Terraform configuration:

```shell
terraform apply
```

When promoted, provide requested variables:

* `project_id` is the GCP project ID (not the name)
* `location` is GCP region to deploy to

When done, this will output the configured resource information. 

## test deployment

To test the deployed `artomator`, use the provided ["hello" Dockerfile](tests/Dockerfile). To build it with both labels (`artomator-sbom=true`) and deploy it, use the `test-image` tool from the root of the repo: 

```shell
tools/test-image
```

## cleanup

To clean all the resources provisioned by this setup run: 

```shell
terraform destroy
```

> Note, this does not remove the created KMS resources, just disables them. 

## disclaimer

This is my personal project and it does not represent my employer. While I do my best to ensure that everything works, I take no responsibility for issues caused by this code.
