# artomator (Artifact Registry Automator, naming is hard)


[![Go Report Card](https://goreportcard.com/badge/github.com/mchmarny/artomator)](https://goreportcard.com/report/github.com/mchmarny/artomator) ![GitHub go.mod Go version](https://img.shields.io/github/go-mod/go-version/mchmarny/artomator) [![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://github.com/gojp/goreportcard/blob/master/LICENSE)

Automates the creation of [Software Bill of Materials (SBOM)](https://www.cisa.gov/sbom), and vulnerability scanning of container images. When deployed in your GCP project, `artomator` will automatically process any image that is pushed into [Artifact Registry (AR)](https://cloud.google.com/artifact-registry) with one of the expected [label](https://docs.docker.com/config/labels-custom-metadata/). For example:

```shell
docker build -t $TAG --label artomator-sbom=spdx --label artomator-vuln=true .
```

The `artomator-sbom=spdx` label in the above `docker build` commend will tell `artomator` to add SBOM attestations in an [SPDX](https://spdx.dev/) format (the supported formats are: `cyclonedx` or `spdx`). Additionally, if you also include the `artomator-vuln=true` label, `artomator` will also generate a vulnerability report from that SBOM. 

![](images/flow.png)

> `artomator` also exposes an attestation verification and runtime vulnerability discovery APIs. See API section for details

## how it works

1. Whenever an image is published to the Artifact Registry 
2. A [registry event](https://cloud.google.com/artifact-registry/docs/configure-notifications) is automatically published if there is a [PubSub](https://cloud.google.com/pubsub/docs/overview) topic named `gcr` in the same project
3. PubSub subscription pushes that event to `artomator` service in [Cloud Run](https://cloud.google.com/run) with the operation type (e.g. `INSERT`) and the image digest (SHA256)
4. The `artomator` service retrieves metadata for that image from the registry and check its labels
5. If the image includes `artomator-*` labels, signs that image using KMS key, and creates the requested artifacts (SBOM or vulnerability report)
6. Adds attestation on the image using the KMS key and stores it all in the registry
7. (optional) If GCS bucket is configured, `artomator` will also persist the generated artifacts
8. Stores the processed image digests in a Redis store to avoid re-processing the same image (technically adding attestation to an image creates yet another event, so this could cause recursion without that check)

To processes images, `artomator` uses:

* [cosign](https://github.com/sigstore/cosign) for image signing and verification
* [syft](https://github.com/anchore/syft) for SBOM generation 
* [trivy](https://github.com/aquasecurity/trivy) for vulnerability scans 
* [jq](https://stedolan.github.io/jq/) for JSON operations 

## artifacts 

> For examples of attestations generated by `artomator` see the SBOM ([sbom.json](sbom.json)) and vulnerability report ([vuln.json](vuln.json)) on the `artomator` itself.

In addition to attaching these to image as attestations, `artomator` also saves all the generated files in GCS. To make these names predictable, `artomator` prefixes them with the SHA from the image digest. For example, if the image digest was:

```shell
us-west1-docker.pkg.dev/cloudy-demos/artomator/tester@sha256:acaccb6c8f975ee7df7f46468fae28fb5014cf02c2835d2dc37bf6961e648838
```

then the list of artifacts in the registry for that image will be: 

* acaccb6c8f975ee7df7f46468fae28fb5014cf02c2835d2dc37bf6961e648838-sbom.json
* acaccb6c8f975ee7df7f46468fae28fb5014cf02c2835d2dc37bf6961e648838-vuln.json
* acaccb6c8f975ee7df7f46468fae28fb5014cf02c2835d2dc37bf6961e648838-meta.json

where:

* `-sbom.json` is SPDX 2.3 formatted SBOM file
* `-vuln.json` is the vulnerability report based on the SBOM based on `trivy` DB
* `-meta.json` is the image metadata in the registry as it was when the image was processed

## api 

`artomator` exposes also APIs for image attestation verification and runtime vulnerability discovery. 

### image attestation verification api

The `artomator` service exposes (GET `/verify`) API which you can query with the image digest to verify the expected attestations on the image.

> Note, access to the `artomator` service requires `roles/run.invoker` IAM role

First, start by exporting the `artomator` service URL:

```shell
export SERVICE_URL=$(gcloud run services describe artomator \
  --region $REGION --format="value(status.url)")
```

Then, to query the verify endpoint:

```shell
curl -i -H "Authorization: Bearer $(gcloud auth print-identity-token)" \
     -H "Content-Type: application/json" \
     -H "X-Goog-User-Project: ${PROJECT_ID}" \
     "${SERVICE_URL}/verify?type=spdx&digest=${IMAGE_DIGEST}"
```

If the required attestation for SPDX formatted SBOM (`https://spdx.dev/Document`) is found, `artomator` will return the entire attestation.


## verify processed image using cosign

To verify the attestation for `artomator` processed images you will need the KMS key name that was used to sign that image. You retrieve it using the following command:

```shell
export SIGN_KEY=$(gcloud kms keys describe artomator-signer \
  --project $PROJECT_ID \
  --location $REGION \
  --keyring artomator \
  --format json | jq --raw-output '.name')
```

You can check the key like this: 

```shell
echo $SIGN_KEY
```

It should look something like this

```shell
projects/$PROJECT_ID/locations/$REGION/keyRings/artomator/cryptoKeys/artomator-signer/cryptoKeyVersions/1
```

Once have the signing key, you can verify any image that was processed by `artomator` like this:

> Note, the `$IMAGE_DIGEST` has to be the fully qualified image URI with the SHA. For example `us-west1-docker.pkg.dev/cloudy-demos/artomator/tester@sha256:59d5b8eb5525307dde52aa51382676e74240bb79eb92a67a1f2a760382a21d78`

```shell
cosign verify-attestation --type=spdx --key "gcpkms://${SIGN_KEY}" $IMAGE_DIGEST \
    | jq -r .payload | base64 -d | jq -r .predicateType
```

> Note, you can check the attestation for either of the two types that `artomator` creates by changing the `--type` flag in the above command to either `spdx` (SBOM), `vuln` which is the vulnerability report

The result should look something like this: 

```shell
Verification for us-west1-docker.pkg.dev/cloudy-demos/artomator/tester@sha256:59d5b8eb5525307dde52aa51382676e74240bb79eb92a67a1f2a760382a21d78 --
The following checks were performed on each of these signatures:
  - The cosign claims were validated
  - The signatures were verified against the specified public key
https://spdx.dev/Document
```

To save any of these artifacts locally: 

```shell
cosign verify-attestation --type=spdx --key "gcpkms://${SIGN_KEY}" $IMAGE_DIGEST \
    | jq -r .payload | base64 -d > sbom.spdx.json
```

## deployment 

To deploy the prebuilt `artomator` first, start by exporting the GCP `PROJECT_ID` to which you want to deploy:

```shell
export PROJECT_ID=<your-project-id-here>
```

Next, deploy the pre-built image:

```shell
make deploy
```

> Note, provisioning some service dependencies may take a few minutes

When done, this will:

* Enable required APIs
* Create artifact registry (`artomator`)
* Configure KMS key (`keyRings/artomator/cryptoKeys/artomator-signer`)
* PubSub topic (`gcr`) and subscription to that topic (`gcr-sub`)
* Deploy Cloud Run service (`artomator`) along with the `redis` dependency 
* Create a GCS bucket (`$PROJECT_ID-artomator`)


> To build your own `artomator` image and deploy everything manually, see [BUILD.md](BUILD.md). 

## test deployment

To test the deployed `artomator`, use the provided ["hello" Dockerfile](tests/Dockerfile). To build it with both labels (`artomator-sbom=true` and `artomator-vuln=true`) and deploy it: 

```shell
make image
```

## cleanup

To delete all created resources run: 

```shell
make clean
```

> Note, this does not remove the created KMS resources. 

## disclaimer

This is my personal project and it does not represent my employer. While I do my best to ensure that everything works, I take no responsibility for issues caused by this code.